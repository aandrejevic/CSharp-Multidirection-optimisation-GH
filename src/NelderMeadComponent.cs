using System; using System.Collections.Generic; using System.Linq; using System.Text; using Grasshopper; using Grasshopper.Kernel; using Rhino.Geometry;  namespace NelderMead {     public class NelderMeadComponent : GH_Component     {         /// <summary>         /// Each implementation of GH_Component must provide a public          /// constructor without any arguments.         /// Category represents the Tab in which the component will appear,          /// Subcategory the panel. If you use non-existing tab or panel names,          /// new tabs/panels will automatically be created.         /// </summary>         public NelderMeadComponent()           : base("NelderMeadComponent", "NM",             "Constructs a Nelder-Mead algorithm for the variables",             "Maths", "Script")         {         }          /// <summary>         /// Registers all the input parameters for this component.         /// </summary>         protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)         {             // Use the pManager object to register your input parameters.             // You can often supply default values when creating parameters.             // All parameters must have the correct access type. If you want              // to import lists or trees of values, modify the ParamAccess flag.              // Input surface parameters             pManager.AddIntegerParameter("X", "X", "X variable", GH_ParamAccess.item);             pManager.AddIntegerParameter("Y", "Y", "Y variable", GH_ParamAccess.item);             //pManager.AddNumberParameter("Z", "Z", "Z variable", GH_ParamAccess.item);             // Input box parameters             //pManager.AddBooleanParameter("Loop", "L", "Loop that signs when to stop", GH_ParamAccess.item, true);              // If you want to change properties of certain parameters,               // you can use the pManager instance to access them by index:             //pManager[0].Optional = true;         }          /// <summary>         /// Registers all the output parameters for this component.         /// </summary>         protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)         {             // Use the pManager object to register your output parameters.             // Output parameters do not have default values, but they too must have the correct access type.             pManager.Register_DoubleParam("Optimal Output", "OO", "The optimal output after the algorithm", GH_ParamAccess.item);             //pManager.AddIntegerParameter("X", "X", "X variable", GH_ParamAccess.item);             //pManager.AddIntegerParameter("Y", "Y", "Y variable", GH_ParamAccess.item);              // Sometimes you want to hide a specific parameter from the Rhino preview.             // You can use the HideParameter() method as a quick way:             //pManager.HideParameter(0);         }          public static double FirstFunction(double x, double y)         {             return (-1*(2 * y - 0.5 * Math.Sqrt(x)));         }  

        /// <summary>         /// This is the method that actually does the work.         /// </summary>         /// <param name="DA">The DA object can be used to retrieve data from input parameters and          /// to store data in output parameters.</param>         protected override void SolveInstance(IGH_DataAccess DA)         {             // Retrieve data and validate             var x = default(int);             var y = default(int);              // Use the DA object to retrieve the data inside the first input parameter.             // If the retieval fails (for example if there is no data) we need to abort.             if (!DA.GetData(0, ref x)) { return; };             if (!DA.GetData(1, ref y)) { return; };              // double output = FirstFunction(simplex[vertex_of_simplex][colom,0], simplex[vertex_of_simplex][colom, 1]);              var scale = 1;             var N = 20;             //var parameters = 2; hier nog for loop maken als meerdere parameters              double[,] start = new double[N + 1, 2];              // Generate N + 1 initial arrays.             for (int array = 0; array < N + 1 ; array++)             {                 //start[array] = new double[] { x - 10 + array, y - 10 + array };                 start[array, 0] = x - 10 + array;                 start[array, 1] = y - 10 + array;             }                          double pn = scale * (Math.Sqrt(N + 1) - 1 + N) / (N * Math.Sqrt(2));             //double qn = scale * (Math.Sqrt(N + 1) - 1) / (N * Math.Sqrt(2));              //double[][] function = new double (2 * y - 0.5 * Math.Sqrt(x));              double[][,] simplex = new double[N + 1][,];              // Generate N + 1 initial arrays.             for (int i = 0; i <= N; i++)             {                 simplex[i] = new double[N,2];                 for (int j = 0; j < N; j++)                 {                     //double[] param = start[j];                     simplex[i][j,0] = (j * pn) + start[i,0];                     simplex[i][j, 1] = (j * pn) + start[i, 1];                 }             }              //Setting parameters of the NM method             const double alpha = 1;             const double gamma = 2;             const double rho = 0.5;             //const double sigma = 0.5;              // Infinite loop until convergence             while (true)             {                 //double output = FirstFunction(simplex[0][0,0], simplex[0][0, 1]);                 // Evaluation                 double[][] functionValues = new double[N + 1][];                 for (int i = 0; i <= N; i++)
                {                     functionValues[i] = new double[N];
                    for (int j =0; j < N; j++)
                    {
                        functionValues[i][j] = 0;
                    }
                }                  int[] indices = new int[N + 1];                 for (int vertex_of_simplex = 0; vertex_of_simplex < functionValues.Length; vertex_of_simplex++)                 {                     for (int colom = 0; colom < N; colom++)                     {                         functionValues[vertex_of_simplex][colom] = FirstFunction(simplex[vertex_of_simplex][colom,0], simplex[vertex_of_simplex][colom, 1]);                     }                      indices[vertex_of_simplex] = vertex_of_simplex;                 }

                ////Save values to see changes in order to ordere the simplex with the lowest fn values
                //// if zo change columns of simplex aswell
                //double[] change = new double[N + 1];                 //for (int i = 0; i < change.Length; i++)
                //{
                //    change[i] = functionValues[i][0];
                //}


                // Order
                //Array.Sort(functionValues, indices);
                for (int index = 0; index < N + 1; index++)
                {
                    Array.Sort(functionValues[index]);
                }                  double[] minFnValues = new double[N + 1];                 for (int array = 0; array < minFnValues.Length; array++)
                {
                    minFnValues[array] = functionValues[array][0];
                }

                ////first check for changes
                //double[,] temp = new double[N , 2];                 //double[][,] new_simplex = new double[N + 1][,];                  //for (int i =0; i < N + 1; i++)                 //{                 //    new_simplex[i] = new double[N, 2];                 //    if (change[i] != minFnValues[i])
                //    {                 //        for (int j = 0; j < N; j++)
                //        {                 //            temp[j,0] = simplex[i][j,0];                 //            temp[j,1] = simplex[i][j, 1];                  //            for (int k = N; k > -1; k--)
                //            {
                //                new_simplex[i][j, 0] = temp[k, 0];
                //                new_simplex[i][j, 1] = temp[k, 1];
                //            }
                //        }
                //    }
                //}                  Array.Sort(minFnValues);                 ////(second) check for changes in row                 //for (int i =0; i < change.Length; i++)                 //{                 //    if (change[i] != minFnValues[i])                 //    {                 //        Array.Reverse(simplex[i]);                 //    }                 //}

                // Find centroid of the simplex excluding the vertex with highest functionvalue.                 //create empty centrois array
                double[,] centroid = new double[N, 2];
                for (int i = 0; i < N; i++)                 {                     for (int j = 0; j < 2; j++)                     {                         centroid[i,j] = 0;                     }                 }

                //// Check for convergence
                //if (Math.Abs(FirstFunction(centroid) - functionValues[0]) < 1e-9)
                //{
                //    break;
                //}

                //Console.WriteLine(simplex);

                // array index out of range error zit hierin!!!
                for (int index = 0; index < N; index++)                 {                     for (int vertex_of_simplex = 0; vertex_of_simplex < N; vertex_of_simplex++)                     {                         if (vertex_of_simplex != indices[N])                         {                             centroid[index, 0] += simplex[vertex_of_simplex][index, 0] / N;                             centroid[index, 1] += simplex[vertex_of_simplex][index, 1] / N;                         }                     }                 }                    //Reflection                 double[,] reflection_point = new double[N, 2];                 for (int i = 0; i < N; i++)                 {                     for (int j = 0; j < 2; j++)                     {                         reflection_point[i, j] = 0;                     }                 }                  for (int index = 0; index < N; index++)                 {                     reflection_point[index,0] = centroid[index,0] + alpha * (centroid[index,0] - simplex[indices[N]][index,0]);                     reflection_point[index, 1] = centroid[index, 1] + alpha * (centroid[index, 1] - simplex[indices[N]][index, 1]);                 }                  double[] reflection_values = new double[N];                 for (int i = 0; i  < N; i++)                 {                     reflection_values[i] = FirstFunction(reflection_point[i,0], reflection_point[i, 1]);                 }                 Array.Sort(reflection_values);                 double reflection_value = reflection_values[0];                   if (reflection_value >= minFnValues[0] & reflection_value < minFnValues[N - 1])                 {                     simplex[indices[N]] = reflection_point;                     continue;                 }                   // Expansion                 if (reflection_value < minFnValues[0])                 {                     double[,] expansion_point = new double[N,2];                     for (int i = 0; i < N; i++)
                    {
                        for (int j = 0; j < 2; j++)
                        {
                            expansion_point[i, j] = 0;
                        }
                    }                      for (int index = 0; index < N; index++)                     {                         expansion_point[index,0] = centroid[index,0] + gamma * (reflection_point[index,0] - centroid[index,0]);                         expansion_point[index, 1] = centroid[index, 1] + gamma * (reflection_point[index, 1] - centroid[index, 1]);                     }                      double[] expansion_values = new double[N];                     for (int i = 0; i < N; i++)                     {                         expansion_values[i] = FirstFunction(expansion_point[i,0], expansion_point[i, 1]);                     }                     Array.Sort(expansion_values);                     double expansion_value = expansion_values[0];                      if (expansion_value < reflection_value)                     {                         simplex[indices[N]] = expansion_point;                     }                     else                     {                         simplex[indices[N]] = reflection_point;                     }                     continue;                 }                  // Contraction                 double[,] contraction_point = new double[N,2];                 for (int i = 0; i < N; i++)                 {                     for (int j = 0; j < 2; j++)                     {                         contraction_point[i, j] = 0;                     }                 }                  for (int index = 0; index < N; index++)                 {                     contraction_point[index,0] = centroid[index,0] + rho * (simplex[indices[N]][index,0] - centroid[index,0]);                     contraction_point[index, 1] = centroid[index, 1] + rho * (simplex[indices[N]][index, 1] - centroid[index, 1]);                 }                  double[] contraction_values = new double[N];                 for (int i = 0; i < N; i++)                 {                     contraction_values[i] = FirstFunction(contraction_point[i, 0], contraction_point[i, 1]);                 }                 Array.Sort(contraction_values);                 double contraction_value = contraction_values[0];                  if (contraction_value < minFnValues[0])                 {                     for (int i = 0; i < N ; i++)
                    {                         simplex[indices[N]][i,0] = contraction_point[i,0];                         simplex[indices[N]][i, 1] = contraction_point[i, 1];
                    }
                    continue;                 }

                //Shrink, als constraction point niet laag genoeg is simplex waarde van laagste fn waarde en meegeven als antwoord.                  double[,] best_point = simplex[N];
                double[][,] best_simplex = new double[N + 1][,];                  // (Pi+Ph)/2 check is better then ols simplex                 for (int vertex_of_simplex = 0; vertex_of_simplex < N + 1; vertex_of_simplex++)                 {                     best_simplex[vertex_of_simplex] = new double[N, 2];                     for (int index = 0; index < N; index++)                     {                         best_simplex[vertex_of_simplex][index,0] = (simplex[vertex_of_simplex][index, 0] + best_point[0,0])/ 2;                         best_simplex[vertex_of_simplex][index, 1] = (simplex[vertex_of_simplex][index, 0] + best_point[0,1]) / 2;                      }                 }                  double temp_fn = FirstFunction(best_simplex[N][0, 0], best_simplex[N][0, 1]);                 if (temp_fn < minFnValues[0])
                {
                    DA.SetData(0, best_simplex[N]);
                }                  DA.SetData(0, simplex[N]);             }         }                      /// <summary>         /// The Exposure property controls where in the panel a component icon          /// will appear. There are seven possible locations (primary to septenary),          /// each of which can be combined with the GH_Exposure.obscure flag, which          /// ensures the component will only be visible on panel dropdowns.         /// </summary>         public override GH_Exposure Exposure         {             get { return GH_Exposure.primary; }         }          /// <summary>         /// Provides an Icon for every component that will be visible in the User Interface.         /// Icons need to be 24x24 pixels.         /// </summary>         protected override System.Drawing.Bitmap Icon         {             get             {                 // You can add image files to your project resources and access them like this:                 //return Resources.IconForThisComponent;                 return null;             }         }          /// <summary>         /// Each component must have a unique Guid to identify it.          /// It is vital this Guid doesn't change otherwise old ghx files          /// that use the old ID will partially fail during loading.         /// </summary>         public override Guid ComponentGuid         {             get { return new Guid("12222943-b497-4051-8828-5a752c8bb78e"); }         }     } }  